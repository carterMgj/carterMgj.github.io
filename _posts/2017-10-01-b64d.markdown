---
layout:     post
title:      "2017XCTF决赛题 -- b64d"
subtitle:   "从一道普通题开始的一些探索"
date:       2017-10-01 22:46:25
author:     "Carter"
header-img: "img/post-bg-rwd.jpg"
tags:
    - Fuzz
    - pwn
---

​     前段时间有幸代表我们战队参加了2017年XCTF总决赛，和国内国外的大佬们有了现场过招的机会。该次决赛赛制也很有意思，不再采用两天都是攻防赛的形式，我是引入了目前IT圈内的大明星 -- 人工智能。总决赛总共两天，第一天是各个战队使用自己开发的AI工具，对主办方放出的题目进行自动化的fuzz，只有当fuzz出该题目的崩溃后，人类选手才能得到该题的二进制程序文件，进行分析和利用的开发；第二天则是过去的老套路，放出了4道pwn题（此次没有web题，心疼web选手5秒钟），进行现场的攻防竞赛。

​     此篇博文，不是挑选比赛中最难的题目进行说明，而是拿一道我觉得最有意思的题目，依次作为研究的起点，进行一些探索。这道题是我们的AI工具在第一天比赛开始后几分钟就fuzz出崩溃的一道题，名称叫做b64d，很明显的一个栈溢出漏洞。

###  一. 漏洞分析

   漏洞存在于main函数内，允许读入2048个base64编码后的字符串，将解码后的字符串v5通过strcpy函数复制到栈上，导致了栈溢出。
![1](D:\Tec\blog\blog_img\2017-10-01-b64d\1.png)

​      程序是amd64结构，保护措施只开了堆栈地址随机化

![2](D:\Tec\blog\blog_img\2017-10-01-b64d\2.png)

### 二. 难点探寻

​     这个简单的栈溢出题目为什么有趣呢？原因在于当我们覆盖其返回地址为shellcode地址时，strcpy遇到'\x00'发生了截断，因此不能够完全覆盖返回地址到bss段存放shellcode的地方。其返回地址覆盖前是一个so库中的地址，因此一旦修改错误程序就会崩溃。

![3](D:\Tec\blog\blog_img\2017-10-01-b64d\3.png)

我们只能在原本的一个so库地址上进行修改。而so库的基址每次都是随机的，我们把返回地址覆盖到哪里？这是亟待解决的问题

### 三. 解决方法
1. 我们从上图中可以看到，在栈顶往下4个地址处，有一个main函数开始的地址。试想：如果我们把返回地址修改成这个地址，再让main函数再运行一次，到ret时的返回地址会不会发生变化呢？  

  于是在gdb中手动修改了ret为main函数开始的地址，再一次回到ret处。此时可喜的看到，ret地址已经是0x0了，此时我们就可以随意覆盖返回地址到任意地方了

![4](D:\Tec\blog\blog_img\2017-10-01-b64d\4.png)

2. 那么该如何完成第一步我们的假设？很容易想到在第一次到达ret时，需要将程序的控制流返回到一个'pop|pop|pop|ret'上，执行完这串gadget后，程序就刚好可以返回到栈顶往下第4个地址处。


3. 要在so库中，找到一个'pppr'地址并不难，需要我们斟酌的是：
 - 选取哪个so库中哪个'pppr'序列？
 - 栈溢出时，覆盖ret本来的地址时，覆盖几个字节？
 - 并且需要考虑到：strcpy在拷贝时，会在末尾自动添加一个字节的'\x00'
