---
layout:     post
title:      "关于程序调用时压栈顺序"
subtitle:   "姑且定义为一个集合Fsb漏洞构造、分析、利用的小实验"
date:       2016-11-18 10:40:25
author:     "Carter"
header-img: "img/post-bg-re-vs-ng2.jpg"
header-mask: 0.3
catalog:    true
tags:
    - pwn
---


<h3 id="一-关于程序调用时压栈顺序">一. 关于程序调用时压栈顺序</h3>

<p>对于函数</p>

<pre class="prettyprint"><code class="language-c++ hljs css"><span class="hljs-tag">func</span>(<span class="hljs-tag">arg</span><span class="hljs-attr_selector">[1]</span>,<span class="hljs-tag">arg</span><span class="hljs-attr_selector">[2]</span>,.....,<span class="hljs-tag">arg</span><span class="hljs-attr_selector">[n]</span>)</code></pre>

<p>压栈顺序为：参数（从右到左）–&gt; 返回地址 –&gt; ebp</p>

<p>压栈后，栈上情况如下：</p>

<hr>

<p>低地址： <br>
　　　ebp <br>
　　　函数返回地址 <br>
　　　arg[1] <br>
　　　arg[2] <br>
　　　 …. <br>
　　　arg[n]　　 <br>
高地址：</p>

<hr>

<p>因此存在诸如格式化字符串等任意内存写漏洞时，Get shell最直接的方法就是：</p>

<p>改写程序返回地址为so库中system函数的地址，同时布置好栈，将参数“/bin/sh\x00”放在’返回地址往后两个单位内存地址’处即可 。为什么要放在其后两个单位内存地址处，原因见（探究程序进入到子函数时，栈的状态）讲解</p>

<p>当程序执行完到ret指令时，跳到system函数地址，就会把 /bin/sh 当做参数执行，获得shell</p>

<h3 id="二-探究程序进入函数前后栈的状态">二. 探究程序进入函数前后，栈的状态</h3>

<p>实验程序代码如下：</p>

<pre class="prettyprint"><code class="language-c++ hljs vala"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-keyword">int</span>  print(<span class="hljs-keyword">char</span>* s)
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">char</span> s[<span class="hljs-number">32</span>] = <span class="hljs-string">"Hello world"</span>;
    print(s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>在print函数处下断，程序停在了调用print函数的地方</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/1.png" alt="图片" title=""></p>

<p>跟进到print函数，进入到函数的时候，栈的情况如下</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/2.png" alt="图片" title=""> <br>
 <br>
 <br>
二. 关于大端模式和小端模式：</p>

<blockquote>
  <p>小端模式：数据的高位对应高地址 <br>
  大端模式：数据的高位对应低地址</p>
</blockquote>

<p>　　举个栗子：对于 0xf76a3a84 这个数，按照其他进制计数规则，左边为高位，右边为地位，因此 0xf7 为最高位，相反，0x84为最低位</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/3.png" alt="图片" title=""></p>

<p>　　因为内存中地址从左到右是依次增大的，所以 0xf76a3a84 这个数在内存中实际分布为： <br>
　　 <br>
<img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/4.png" alt="图片" title=""></p>

<p>也就是数据最高位对应高地址，最低位对应低地址</p>



<h3 id="三-关于elf程序的几个段">三.  关于ELF程序的几个段</h3>

<p>一个程序一般分为3段:text段,data段,bss段 <br>
text段:  可读可执行，存放程序代码,编译时确定 <br>
data段:  只可读，存放在编译阶段(而非运行时)就能确定的数据, <br>
就是通常所说的静态存储区,赋了初值的全局变量、静态变量和常量存放在这个区域 <br>
bss段:   可读可写，定义时没有赋初值的全局变量和静态变量,放在这个区域，比如程序的got表地址就位于该区域</p>

<p>如图：</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/5.png" alt="图片" title=""></p>

<ol>
<li>可读可执行，为程序的 text段–代码段</li>
<li>只可读，为程序的 bss段</li>
<li>可读可写，为程序的 data段</li>
</ol>

<p>注意：当利用漏洞修改某个地址的值时，首先需要把握整个程序结构，搞清楚该变量是什么变量，其地址位于程序的哪个段，这个段有写入权限你才能修改，否则程序会报‘Segment Defaults’</p>

<h3 id="四-got表和plt表">四.   got表和plt表</h3>

<p>在linux漏洞利用中，很重要的两个概念</p>

<p>首先需要记住：</p>

<ul>
<li>plt表中存放的是一段汇编代码(jmp *got_addr)</li>
<li>got表中存放的仅仅是一个地址数据，即so库中某函数加载的内存地址</li>
</ul>

<p>在函数func被调用时，首先会跳转到func的plt表地址，该地址存放了一段jmp *addr的汇编代码，在该函数第一次调用时，addr中存放的是：查询func函数加载到内存的真正地址的相应代码的地址；查询到后，函数真实地址被写入到函数got表地址：got_addr中，当第二次调用时，plt表存储的汇编代码为 jmp *got_addr，即跳转到函数真正代码处执行</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/6.png" alt="图片" title=""></p>

<p>五.  二进制文件与python利用脚本交互 调试技巧</p>

<ol>
<li>在写的python脚本中写入： <br>
from pwn import * <br>
conn = process(‘./pwn1’)   #echo为要进行pwn的程序名称 <br>
raw_input(‘pause’)</li>
<li>运行 python 脚本</li>
<li>输入sudo gdb pwn1 <code>pidof pwn1</code> 进入到gdb调试，pdisass反汇编一下函数或者IDA静态查看，在你感兴趣的位置下好断点</li>
<li>在gdb中输入 c (continue) ，让程序继续执行</li>
<li>此时的python脚本会停在 raw_input(‘pause’)这句，等待输入；当gdb attach上去并且下断都完成以后，在python脚本的bash里按一下回车，python脚本就跑起来了，就可以开始一步步跟踪python脚本与程序的交互过程了  </li>
</ol>



<h3 id="六-对于-leave-ret指令的理解">六. 对于 leave ，ret指令的理解</h3>

<p>leave做的事情：</p>

<ul>
<li>new_esp  = old_ebp + 4 （因为栈的地址是从高地址往低地址增长）</li>
<li>new_ebp = * old_ebp</li>
</ul>

<p>如下图所示，在运行leave指令之前，EBP和ESP情况如下：</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/7.png" alt="图片" title=""></p>

<p>运行完leave指令后，新的EBP和ESP情况如下：</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/8.png" alt="图片" title=""></p>

<p>ret做的事情： <br>
    跳转到栈顶位置内容所代表的地址</p>

<p><img src="https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-11-18-pwn-base-knowledge/9.png" alt="图片" title=""></p>

<p>运行完ret指令 后，程序调转到 0x8049407 处，同时 ESP = ESP+4</p>



<h3 id="七-对于call指令对栈帧的影响探究">七. 对于call指令对栈帧的影响探究</h3>

<p><strong>32bit下：</strong></p>

<p>call指令执行结束后会降低栈帧，降低的大小取决于该函数参数的个数n，即：栈帧esp降低大小 = n*4  (n为函数参数个数)</p>

<p>原因也比较好理解，在调用call前，push指令将该函数的参数依次压入到栈中；在call指令执行后，将有相应多的pop指令将参数弹出，从而降低栈帧，最后返回的时候，自然esp也就降低了</p>

<p><strong>64bit下：</strong></p>

<p>因为64bit下，函数调用是通过寄存器传递参数</p>

<blockquote>
  <p>rdi &gt; rsi &gt; rdx &gt; rcx &gt; r8 &gt; r9</p>
</blockquote>

<p>所以函数调用前后，对栈是没有影响的</p>