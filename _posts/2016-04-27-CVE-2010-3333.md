---
layout:     post
title:      "CVE-2010-3333分析报告"
subtitle:   "多实践、勤总结"
date:       2016-04-27 11:56:33
author:     "Carter"
header-img: "img/wallhaven-457073.jpg"
tags:
    - pwn
    - windows漏洞调试
---

### 写在前面

CVE-2010-3333是Microsoft Office 在处理RTF中的“pFragments”属性时存在栈溢出，通过对此漏洞的调试，加深对windows下漏洞的理解和熟练调试技巧。遂将调试分析过程记录如下。

### 一. 调试环境

 - xp_sp3简体中文版 ,
 - windbg
 - Microsoft Office word 2003 11.5604.5606

### 二. 调试过程

>生成poc

从利用metasploit生成该漏洞的恶意文档msf.rtf
```sh
Search cve-2010-3333
Use exploit/windows/fileformats/ms10_087_rtf_pfragments_bof
info
```
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/1.png)
```sh
Set target 6
expliot
```



>分析崩溃原因

崩溃现场如下。程序崩溃在了循环赋值语句上，原因是向edi=130000写入数据时，发生了非法内存写错误
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/2.png)

定位漏洞位置
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/3.png)

可知漏洞出现在office自带的mso.dll中，查看该模块详细信息如下
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/4.png)

查看内存地址130000 和 其稍微前面一点的地址属性。通过此可以得出，程序是在往栈上依次写数据，当超过地址130000时，内存属性为只读，因此触发了非法写入异常
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/5.png)

在崩溃点30e9eb88下断，重新运行程序。程序在第一次调用该语句时断下，查看栈回溯信息。栈回溯的原理就是通过当前栈底的ebp中存放了上一个函数的ebp位置，因此可以一直往前推算出前n次调用
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/6.png)

由此可见，是在函数mso!Ordinal753+0x306e中调用了crashFunc，crashFunc函数的首地址为30f4cc5d
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/7.png)




>探究漏洞原理

在crashFunc首地址30f4cc5d下断，重新运行程序
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/8.png)
该函数首先在栈上开辟了0x14字节大小的栈空间

当运行到触发漏洞的那句指令时，我们来看看此时的内存情况
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/9.png)

此时通过rep指令循环的进行赋值操作，赋值的起始地址为0x123dc0，仅仅与ebp相差0x10=16字节，赋值的单位为dword，也就是说如果赋值次数大于16/4=4次，就会覆盖ebp，再接下去就是返回地址了。

通过分析附近的汇编指令，可知控制赋值次数的为eax，此时eax的值为0xc8ac，远远大于4，因此造成了栈溢出



>追踪污点数据

造成栈溢出的罪魁祸首找到了，即eax中的0xc8ac，这就是为污点数据。我们在指令30e8eb88之前的指令中，寻找eax的数据是怎么来的
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/10.png)

由此可知，0xc8ac是一个内存中的数据，在这个函数中，只是通过两条命令将这个数据读给了eax。那么接下来我们在恶意文件中寻找污点数据。用010editor打开msf.rtf，使用text方式搜索字符串‘acc8’
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/11.png)

### 三. 漏洞利用

使用windbg的narly插件，查看mso.dll开启的安全措施
```sh
.load narly
!nmod
```
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/12.png)
可知mso.dll这个模块GS，safeseh均没有开启，只需要覆盖返回地址为call esp地址即可利用成功

找到30324366处的call esp作为跳板指令
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/13.png)

利用成功截图
![img](https://raw.githubusercontent.com/carterMgj/blog_img/master/2016-04-27-CVE-2010-3333/14.png)